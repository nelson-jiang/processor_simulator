# processor_simulation
1  IntroductionThis project represents a substantive programming exercise.  Like all work for this class, it is to be completedindividually:  any form of collaboration is prohibited, as detailed in the syllabus.  This project is considereda take-home exam.Before even reading this assignment,  please read the E20 manual thoroughly.  Read the provided E20assembly language examples.2  Assignment: SimulatorYour  task  is  to  write  an  E20  simulator:  a  program  that  will  execute  E20  machine  language.   Normally,machine language would be executed by a processor, but for simplicity, we will reproduce the behavior of anE20 processor in software.  A correct simulator is one that will produce identical results to those producedby a real E20 processor, as described in the E20 manual.Each E20 machine language program is a sequence of commands to be interpreted by an E20 processor,or a simulation thereof.  Your simulator will need to accurately reproduce the state that is manipulated bythose commands:  the program counter, the general-purpose registers, and memory.For  example,  consider  the  machine  language  instruction0010100010000011.   This  machine  languageinstruction corresponds to the assembly language instructionaddi$1,$2, 3. Therefore, in order to executethis instruction, we must first know the current value of register$2.  We add 3 to that value, and store thesum in register$1.  This new value may then be accessed by subsequent instructions.The basic operation of your simulator is as follows:1.  Initialize the processor state, including the program counter, the general-purpose registers, and memory.2.  Examine the instruction pointed to by the program counter.  Determine what action is to be taken.3.  Take the indicated action, updating the value of the program counter, the general-purpose registers,and memory appropriately.4.  If the executed instruction is ahaltinstruction, end the simulation.5.  Otherwise, go to step 2.For the purposes of this simulation, the initial state of the program counter is zero, and the initial stateof all registers is zero.  The machine code program will be loaded into memory starting at address zero, andthe value of all other memory cells is zero.2.1  InputThe input to your simulator will be the name of an E20 machine language file, given on the command line.By convention, E20 machine language files have an.binsuffix.Your program will read in the contents of the file.  You may assume that the file contains well-formedE20 machine language code.  The file may contains comments, which your program should ignore.1
You are provided with several examples of valid E20 machine language files, which you can use to testyour simulator.Here is an example of an E20 machine language program, in a file namedloop3.bin, which was producedby assembling the fileloop3.s:ram[0] = 16’ b0000000000010000;          // add$1 ,$0 ,$0ram[1] = 16’ b0000000001000000;          // add$4 ,$0 ,$0ram[2] = 16’ b1000000110001001;          // lw$3 ,value($0)ram[3] = 16’ b1110110010010100;          // loop: slti$1 ,$3 ,20ram[4] = 16’ b1100010000000011;          // jeq$1 ,$0 ,skipram[5] = 16’ b0001000111000000;          // add$4 ,$4 ,$3ram[6] = 16’ b0010110110000001;          // addi$3 ,$3 ,1ram[7] = 16’ b1100000001111011;          // jeq$0 ,$0 ,loopram[8] = 16’ b0100000000001000;          // skip: haltram[9] = 16’ b0000000000010000;          //  value: add$1 ,$0 ,$0Note that each line consists of a memory address, followed by an equals sign, followed by a 16-bit binarynumber in Verilog syntax, followed by a semicolon.  Comments, if present, will be in Verilog syntax.2.2  OutputYour program should print to stdout the final state of the simulated E20 processor, at the point when thesimulation  halts.   Specifically,  your  program  should  print  out  the  final  value  of  the  program  counter  (inunsigned decimal) and the eight general-purpose registers (in unsigned decimal).  In addition, your programshould print out the value of the first 128 memory cells (in hex).Below is an example invocation of a simulator from Linux’sbash.  In this case, we are simulating theexecution of the machine language program given above.  Text in italics represents a command typed by theuser.user@ubuntu:∼/e20$./sim.py loop3.binFinal  state:pc=     8$0=     0$1=     0$2=     0$3=    20$4=    70$5=     0$6=     0$7=     00010  0040  8189 2c94  c403 11c0 ed81  c07b4008  0010  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00002
0000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  00000000  0000  0000  0000  0000  0000  0000  0000Your simulator should produce output in exactly the format shown above.  Note that register values areprinted as unsigned decimal numbers, and memory cells are printed as 4-digit hexadecimal number.Your solution will be checked mechanically, so it is important that your simulator produce output identicalto the output above.  Please avoid losing points for superficial deviations.2.3  TestingSeveral example machine code files have been provided for you.  In addition,  with each machine code fileyou can find the corresponding assembly language file, which includes the expected execution result.  Youcan use these machine code files to verify the correctness of your simulator.  However, you should not relyexclusively on these examples,  as they are not sufficient to exercise every aspect of a simulator.  You aretherefore expected to develop your own test cases.Combining with assemblerWe have uploaded an E20 assembler (vea) in Anubis, so that you can nowrun any E20 assembly language program in your simulator.  First, you must convert the assembly code intomachine code with the uploaded assembler.  Then, you can run the machine code in the simulator.The uploaded assembler (vea) can convert an assembly language file (with a.ssuffix) into a machinelanguage file (with a.binsuffix).  Please follow the instructions in the veareadme file for detail informationof  how  to  use  the  uploaded  assembeler  (vea)  and  get  the  machine  code.   This  may  help  you  to  generateyour own test cases using E20 assembly instructions and then use this uploaded assember (vea) to get thecorresponding machine code.  Once you have the machine code, you can run it on your E20 simulator andcheck whether you are getting expected output.2.4  Starter codeYou  may,  but  are  not  required  to,  use  the  provided  starter  code  for  this  assignment,  found  in  the  filessim-starter.cppandsim-starter.py.  Please rename them tosim.cpporsim.py, as appropriate.Note that the starter code provides a function that will parse the machine code file into a memory array(load_machine_code), and also a function to generate output in the correct format (print_state).  Youshould make use of these functions.3
3  HintsIn order to run a Python program from the Linux command line, it must first be marked executable.Otherwise, you may get a “permission denied” error message.To  mark  your  Python  file  as  executable,  use  the  following  command  (assuming  your  file  is  namedsim.py) frombash:chmod u+x sim.pyAlso make sure that the first line of the file specifies the path to the Python interpreter:  it should be#!/usr/bin/python3.  See the provided starter code.  If you get an “exec format error,” the problemis usually that that the first line is wrong.Alternatively, you can run the program by typingpython3 sim.py.Your program must access its command-line parameters in order to know the name of the machinecode file.  In Python, you can usesys.argv[1], although I recommend you use theargparselibrary,as shown in the starter code.  In C++, you should use theargvparameter tomain.The use of strings to store binary numbers isstrongly discouraged.  In short:  numbers are numbersand  should  be  stored  as  such;  converting  numbers  to  strings  for  the  purpose  of  bit-extraction  andbit-twiddling will lead to inflexible, unreadable code, and may introduce unanticipated bugs.Please review the bit-twiddling techniques, in which we advise you of techniques to manipulate bits ina number without resorting to strings.In  order  to  get  a  good  grade  in  this  assignment,  you  will  need  to  consider  many  edge  cases  in  theE20 design.  You are strongly advised to carefully read the entire sections of the E20 manual coveringarchitecture and instruction set, and ensure that every detail is reflected in your program.  Here is anincomplete list of questions for consideration as your read the manual:–What are the initial values of the registers, the program counter, and the memory cells?–What should happen if a program sets a register to a value outside of the range expressible as a16-bit unsigned number?  Consider both positive and negative numbers that cannot be expressedin 16 bits.–What should happen if a program tries to change the value of$0?–What should happen if a program usessltto compare a negative number to a positive number?–What range of memory address are valid?  What should happen if a program tries to read or writea memory cell whose address is outside of the range of valid addresses?–What should happen if a program sets the program counter to a value outside of the range ofvalid addresses?–What should happen if a program uses a negative immediate value inaddiorjeq?–What should happen if a program uses a negative immediate value inlworsw?–What should happen if a program modifies a memory cell containing machine code?–What should happen if the program counter reaches the address of the last memory cell?–When should your simulator stop?You  should  be  able  to  answer  all  of  these  questions,  and  others,  before  you  start  coding.   You  areencouraged to write test cases for each of these situations, so that you can verify that your simulatorhandles them correctly.4
Your simulator should never crash for any valid input.  This is because your simulator should reproducethe behavior of a hardware component thatcannotcrash.In this case, “valid input” means a machine-code program (i.e.  a sequence of 16-bit values) such thatno invalid instruction is ever executed.If you are using C++, remember to initialize all variables. Uninitialized variables may have an arbitraryvalue that varies between executions or environments, resulting in apparently “random” behavior whenthe program is run.4  RulesLanguageYou should implement this project in Python 3 or in C++.File  names  and  buildingIf  you  are  using  Python  3,  you  must  name  your  programsim.py.   If  yoursolution consists of multiple source files, submit them as well.  Assume that your program will be invokedby runningsim.pywith a filename as its parameter, using Python 3.6.If you are using C++, you must name your program’s main source filesim.cpp.  If your solution consistsof multiple source files, submit them as well.  Assume that your program will be built by gcc 8.3.x using thecommandg++ -Wall -o sim *.cppand then run by the executablesimwith a filename as its parameter.If you use C++, your program should compile cleanly (i.e.  no errors or warnings) with gcc 8.3.x.LibrariesYou are free to make use of all packages of the standard library of your language (that is, alllibraries  that  are  installed  by  default  with  Python  3  or  C++,  respectively).   Do  not  use  any  additionalexternal libraries.  Do not use any OS-specific or compiler-specific extensions.ToolsYour program submission will be evaluated by running it under the GNU/Linux operating system,in particular a Debian or Ubuntu distribution.  Your grade will therefore reflect the behavior of your projectcode  when  executed  in  such  an  environment.   While  you  are  welcome  to  develop  your  project  under  anyoperating  system  you  like  (such  as  Windows  or  Mac  OS),  you  are  responsible  for  any  operating  system-dependent deviations in program behavior.Academic integrityYou should write this assignment entirely on your own.  You are specifically prohib-ited from submitting code written or inspired by someone else.  Code may not be developed collaboratively.You may rely on publicly-accessible documentation of the language and its libraries.  Please read the syllabusfor detailed rules and examples about academic integrity.Code qualityYou should adhere to the conventions of quality code:Indentation and spacing should be both consistent and appropriate.Names of variables, types, fields, and functions should be descriptive.  Local variables may have shortnames if their use is clear from context.All  functions  should  have  a  documenting  comment  in  the  appropriate  style  describing  its  purpose,behavior, inputs, and outputs.  In addition, where appropriate, code should be commented to describeits purpose and method of operation.Your code should be structured to avoid needless redundancy and to enhance maintainability.In short, your submitted code should reflect professional quality.  Your code’s quality is taken into accountin grading your work.5
SubmissionYou are obligated to write aREADMEfile and submit it with your assignment.  TheREADMEshould be a plain text file (not a PDF file and certainly not a Word file) containing the following information:Your name and NYU email address.The state of your work.  Did you complete the assignment?  If not, what is missing?  Be specific.  Ifyour assignment is incomplete or has known bugs, I prefer that students let me know, rather than letme discover these deficiencies on my own.Any other resources you may have used in developing your program.Justify your design decisions.  Why did you write your program the way you did?  If you feel that yourdesign has notable strengths or weaknesses, discuss them.Submit your work on Gradescope.  Submit all source files necessary to build and run your project.  Donot submit external library code.  Do not submit binary executable file
